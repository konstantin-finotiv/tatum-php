<?php

/**
 * Transaction Model
 *
 * @copyright (c) 2022-2023 tatum.io
 * @license   MIT
 * @package   Tatum
 * @author    Mark Jivko
 * @link      https://tatum.io/
 *
 * NOTE: This class is auto generated by tatum.io
 * Do not edit this file manually
 */

namespace Tatum\Model;

use InvalidArgumentException as IAE;

/**
 * Transaction Model
 */
class Transaction extends AbstractModel {

    public const DISCRIMINATOR = null;
    public const OPERATION_TYPE_PAYMENT = 'PAYMENT';
    public const OPERATION_TYPE_WITHDRAWAL = 'WITHDRAWAL';
    public const OPERATION_TYPE_BLOCKCHAIN_TRANSACTION = 'BLOCKCHAIN_TRANSACTION';
    public const OPERATION_TYPE_EXCHANGE = 'EXCHANGE';
    public const OPERATION_TYPE_FAILED = 'FAILED';
    public const OPERATION_TYPE_DEPOSIT = 'DEPOSIT';
    public const OPERATION_TYPE_MINT = 'MINT';
    public const OPERATION_TYPE_REVOKE = 'REVOKE';
    public const TRANSACTION_TYPE_FAILED = 'FAILED';
    public const TRANSACTION_TYPE_DEBIT_PAYMENT = 'DEBIT_PAYMENT';
    public const TRANSACTION_TYPE_CREDIT_PAYMENT = 'CREDIT_PAYMENT';
    public const TRANSACTION_TYPE_CREDIT_DEPOSIT = 'CREDIT_DEPOSIT';
    public const TRANSACTION_TYPE_DEBIT_WITHDRAWAL = 'DEBIT_WITHDRAWAL';
    public const TRANSACTION_TYPE_CANCEL_WITHDRAWAL = 'CANCEL_WITHDRAWAL';
    public const TRANSACTION_TYPE_DEBIT_OUTGOING_PAYMENT = 'DEBIT_OUTGOING_PAYMENT';
    public const TRANSACTION_TYPE_CREDIT_INCOMING_PAYMENT = 'CREDIT_INCOMING_PAYMENT';
    public const TRANSACTION_TYPE_EXCHANGE_BUY = 'EXCHANGE_BUY';
    public const TRANSACTION_TYPE_EXCHANGE_SELL = 'EXCHANGE_SELL';
    protected static $_name = "Transaction";
    protected static $_definition = [
        "account_id" => ["accountId", "string", null, "getAccountId", "setAccountId", null], 
        "counter_account_id" => ["counterAccountId", "string", null, "getCounterAccountId", "setCounterAccountId", null], 
        "currency" => ["currency", "string", null, "getCurrency", "setCurrency", null], 
        "amount" => ["amount", "string", null, "getAmount", "setAmount", null], 
        "anonymous" => ["anonymous", "bool", null, "getAnonymous", "setAnonymous", null], 
        "created" => ["created", "float", null, "getCreated", "setCreated", null], 
        "market_value" => ["marketValue", "\Tatum\Model\MarketValue", null, "getMarketValue", "setMarketValue", null], 
        "operation_type" => ["operationType", "string", null, "getOperationType", "setOperationType", null], 
        "transaction_type" => ["transactionType", "string", null, "getTransactionType", "setTransactionType", null], 
        "reference" => ["reference", "string", null, "getReference", "setReference", null], 
        "transaction_code" => ["transactionCode", "string", null, "getTransactionCode", "setTransactionCode", null], 
        "sender_note" => ["senderNote", "string", null, "getSenderNote", "setSenderNote", null], 
        "recipient_note" => ["recipientNote", "string", null, "getRecipientNote", "setRecipientNote", null], 
        "payment_id" => ["paymentId", "string", null, "getPaymentId", "setPaymentId", null], 
        "attr" => ["attr", "string", null, "getAttr", "setAttr", null], 
        "address" => ["address", "string", null, "getAddress", "setAddress", null], 
        "tx_id" => ["txId", "string", null, "getTxId", "setTxId", null]
    ];

    /**
     * Transaction
     *
     * @param mixed[] $data Model data
     */
    public function __construct(array $data = []) {
        foreach(static::$_definition as $k => $v) {
            $this->_data[$k] = isset($data[$k]) ? $data[$k] : $v[5];
        }
    }
    
    /**
     * {@inheritdoc}
     */
    public function listInvalidProperties(): array {
        $ip = [];
        if (is_null($this->_data['account_id'])) {
            $ip[] = "'account_id' can't be null";
        }
        if (is_null($this->_data['currency'])) {
            $ip[] = "'currency' can't be null";
        }
        if (is_null($this->_data['amount'])) {
            $ip[] = "'amount' can't be null";
        }
        if (is_null($this->_data['anonymous'])) {
            $ip[] = "'anonymous' can't be null";
        }
        if (is_null($this->_data['created'])) {
            $ip[] = "'created' can't be null";
        }
        if (is_null($this->_data['market_value'])) {
            $ip[] = "'market_value' can't be null";
        }
        if (is_null($this->_data['operation_type'])) {
            $ip[] = "'operation_type' can't be null";
        }
        $allowed = $this->getOperationTypeAllowableValues();
        $value = $this->_data['operation_type'];
        if (!is_null($value) && !in_array($value, $allowed, true)) {
            $ip[] = sprintf("'operation_type' invalid value '%s', must be one of '%s'", $value, implode("', '", $allowed));
        }
        if (is_null($this->_data['transaction_type'])) {
            $ip[] = "'transaction_type' can't be null";
        }
        $allowed = $this->getTransactionTypeAllowableValues();
        $value = $this->_data['transaction_type'];
        if (!is_null($value) && !in_array($value, $allowed, true)) {
            $ip[] = sprintf("'transaction_type' invalid value '%s', must be one of '%s'", $value, implode("', '", $allowed));
        }
        if (is_null($this->_data['reference'])) {
            $ip[] = "'reference' can't be null";
        }
        return $ip;
    }

    /**
     * Get allowable values
     *
     * @return scalar[]
     */
    public function getOperationTypeAllowableValues(): array {
        return [
            self::OPERATION_TYPE_PAYMENT,
            self::OPERATION_TYPE_WITHDRAWAL,
            self::OPERATION_TYPE_BLOCKCHAIN_TRANSACTION,
            self::OPERATION_TYPE_EXCHANGE,
            self::OPERATION_TYPE_FAILED,
            self::OPERATION_TYPE_DEPOSIT,
            self::OPERATION_TYPE_MINT,
            self::OPERATION_TYPE_REVOKE,
        ];
    }
    /**
     * Get allowable values
     *
     * @return scalar[]
     */
    public function getTransactionTypeAllowableValues(): array {
        return [
            self::TRANSACTION_TYPE_FAILED,
            self::TRANSACTION_TYPE_DEBIT_PAYMENT,
            self::TRANSACTION_TYPE_CREDIT_PAYMENT,
            self::TRANSACTION_TYPE_CREDIT_DEPOSIT,
            self::TRANSACTION_TYPE_DEBIT_WITHDRAWAL,
            self::TRANSACTION_TYPE_CANCEL_WITHDRAWAL,
            self::TRANSACTION_TYPE_DEBIT_OUTGOING_PAYMENT,
            self::TRANSACTION_TYPE_CREDIT_INCOMING_PAYMENT,
            self::TRANSACTION_TYPE_EXCHANGE_BUY,
            self::TRANSACTION_TYPE_EXCHANGE_SELL,
        ];
    }

    /**
     * Get account_id
     *
     * @return string
     */
    public function getAccountId(): string {
        return $this->_data["account_id"];
    }

    /**
     * Set account_id
     * 
     * @param string $account_id Source account - source of transaction(s)
     * @return $this
     */
    public function setAccountId(string $account_id) {
        $this->_data['account_id'] = $account_id;

        return $this;
    }

    /**
     * Get counter_account_id
     *
     * @return string|null
     */
    public function getCounterAccountId(): ?string {
        return $this->_data["counter_account_id"];
    }

    /**
     * Set counter_account_id
     * 
     * @param string|null $counter_account_id Counter account - transaction(s) destination account. In case of blockchain recipient, this is addess of blockchain account.
     * @return $this
     */
    public function setCounterAccountId(?string $counter_account_id) {
        $this->_data['counter_account_id'] = $counter_account_id;

        return $this;
    }

    /**
     * Get currency
     *
     * @return string
     */
    public function getCurrency(): string {
        return $this->_data["currency"];
    }

    /**
     * Set currency
     * 
     * @param string $currency Transaction currency
     * @return $this
     */
    public function setCurrency(string $currency) {
        $this->_data['currency'] = $currency;

        return $this;
    }

    /**
     * Get amount
     *
     * @return string
     */
    public function getAmount(): string {
        return $this->_data["amount"];
    }

    /**
     * Set amount
     * 
     * @param string $amount Amount in account's currency
     * @return $this
     */
    public function setAmount(string $amount) {
        $this->_data['amount'] = $amount;

        return $this;
    }

    /**
     * Get anonymous
     *
     * @return bool
     */
    public function getAnonymous(): bool {
        return $this->_data["anonymous"];
    }

    /**
     * Set anonymous
     * 
     * @param bool $anonymous Whether the transaction is anonymous. If true, counter account owner does not see source account.
     * @return $this
     */
    public function setAnonymous(bool $anonymous) {
        $this->_data['anonymous'] = $anonymous;

        return $this;
    }

    /**
     * Get created
     *
     * @return float
     */
    public function getCreated(): float {
        return $this->_data["created"];
    }

    /**
     * Set created
     * 
     * @param float $created Time in UTC of transaction.
     * @return $this
     */
    public function setCreated(float $created) {
        $this->_data['created'] = $created;

        return $this;
    }

    /**
     * Get market_value
     *
     * @return \Tatum\Model\MarketValue
     */
    public function getMarketValue(): \Tatum\Model\MarketValue {
        return $this->_data["market_value"];
    }

    /**
     * Set market_value
     * 
     * @param \Tatum\Model\MarketValue $market_value market_value
     * @return $this
     */
    public function setMarketValue(\Tatum\Model\MarketValue $market_value) {
        $this->_data['market_value'] = $market_value;

        return $this;
    }

    /**
     * Get operation_type
     *
     * @return string
     */
    public function getOperationType(): string {
        return $this->_data["operation_type"];
    }

    /**
     * Set operation_type
     * 
     * @param string $operation_type Type of operation.
     * @return $this
     */
    public function setOperationType(string $operation_type) {
        $allowed = $this->getOperationTypeAllowableValues();
        if (!in_array($operation_type, $allowed, true)) {
            throw new IAE(sprintf("Transaction.setOperationType: operation_type invalid value '%s', must be one of '%s'", $operation_type, implode("', '", $allowed)));
        }
        $this->_data['operation_type'] = $operation_type;

        return $this;
    }

    /**
     * Get transaction_type
     *
     * @return string
     */
    public function getTransactionType(): string {
        return $this->_data["transaction_type"];
    }

    /**
     * Set transaction_type
     * 
     * @param string $transaction_type Type of payment.
     * @return $this
     */
    public function setTransactionType(string $transaction_type) {
        $allowed = $this->getTransactionTypeAllowableValues();
        if (!in_array($transaction_type, $allowed, true)) {
            throw new IAE(sprintf("Transaction.setTransactionType: transaction_type invalid value '%s', must be one of '%s'", $transaction_type, implode("', '", $allowed)));
        }
        $this->_data['transaction_type'] = $transaction_type;

        return $this;
    }

    /**
     * Get reference
     *
     * @return string
     */
    public function getReference(): string {
        return $this->_data["reference"];
    }

    /**
     * Set reference
     * 
     * @param string $reference Transaction internal reference - unique identifier within Tatum ledger. In order of failure, use this value to search for problems.
     * @return $this
     */
    public function setReference(string $reference) {
        $this->_data['reference'] = $reference;

        return $this;
    }

    /**
     * Get transaction_code
     *
     * @return string|null
     */
    public function getTransactionCode(): ?string {
        return $this->_data["transaction_code"];
    }

    /**
     * Set transaction_code
     * 
     * @param string|null $transaction_code For bookkeeping to distinct transaction purpose.
     * @return $this
     */
    public function setTransactionCode(?string $transaction_code) {
        $this->_data['transaction_code'] = $transaction_code;

        return $this;
    }

    /**
     * Get sender_note
     *
     * @return string|null
     */
    public function getSenderNote(): ?string {
        return $this->_data["sender_note"];
    }

    /**
     * Set sender_note
     * 
     * @param string|null $sender_note Note visible for sender.
     * @return $this
     */
    public function setSenderNote(?string $sender_note) {
        $this->_data['sender_note'] = $sender_note;

        return $this;
    }

    /**
     * Get recipient_note
     *
     * @return string|null
     */
    public function getRecipientNote(): ?string {
        return $this->_data["recipient_note"];
    }

    /**
     * Set recipient_note
     * 
     * @param string|null $recipient_note Note visible for both sender and recipient.
     * @return $this
     */
    public function setRecipientNote(?string $recipient_note) {
        $this->_data['recipient_note'] = $recipient_note;

        return $this;
    }

    /**
     * Get payment_id
     *
     * @return string|null
     */
    public function getPaymentId(): ?string {
        return $this->_data["payment_id"];
    }

    /**
     * Set payment_id
     * 
     * @param string|null $payment_id Payment ID defined in payment order by sender.
     * @return $this
     */
    public function setPaymentId(?string $payment_id) {
        $this->_data['payment_id'] = $payment_id;

        return $this;
    }

    /**
     * Get attr
     *
     * @return string|null
     */
    public function getAttr(): ?string {
        return $this->_data["attr"];
    }

    /**
     * Set attr
     * 
     * @param string|null $attr Present only for operationType WITHDRAWAL and XLM / XRP based accounts it represents message or destinationTag of the recipient, if present.
     * @return $this
     */
    public function setAttr(?string $attr) {
        $this->_data['attr'] = $attr;

        return $this;
    }

    /**
     * Get address
     *
     * @return string|null
     */
    public function getAddress(): ?string {
        return $this->_data["address"];
    }

    /**
     * Set address
     * 
     * @param string|null $address For operationType DEPOSIT it represents address, on which was deposit credited for the account.
     * @return $this
     */
    public function setAddress(?string $address) {
        $this->_data['address'] = $address;

        return $this;
    }

    /**
     * Get tx_id
     *
     * @return string|null
     */
    public function getTxId(): ?string {
        return $this->_data["tx_id"];
    }

    /**
     * Set tx_id
     * 
     * @param string|null $tx_id For operationType DEPOSIT, BLOCKCHAIN_TRANSACTION it represents transaction id, for which deposit occured.
     * @return $this
     */
    public function setTxId(?string $tx_id) {
        $this->_data['tx_id'] = $tx_id;

        return $this;
    }
}
