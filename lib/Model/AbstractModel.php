<?php

/**
 * Abstract Model
 *
 * @copyright (c) 2022-2023 tatum.io
 * @license   MIT
 * @package   Tatum
 * @author    Mark Jivko
 * @link      https://tatum.io/
 *
 * NOTE: This class is auto generated by tatum.io
 * Do not edit this file manually
 */

namespace Tatum\Model;

use ArrayAccess;
use InvalidArgumentException;
use Tatum\Sdk\Serializer;

abstract class AbstractModel implements ModelInterface, ArrayAccess, \JsonSerializable {
    /**
     * Model name
     */
    protected static $_name = "";

    /**
     * Property definitions
     *
     * @var mixed
     */
    protected static $_definition = [];

    /**
     * Additional properties
     */
    protected $_props = [];

    /**
     * Property values
     */
    protected $_data = [];

    /**
     * {@inheritdoc}
     *
     * @return string[]
     */
    public static function attributeMap(): array {
        return array_map(function ($item) {
            return $item[0];
        }, static::$_definition);
    }

    /**
     * {@inheritDoc}
     *
     * @return string[]
     */
    public static function openAPITypes(): array {
        return array_map(function ($item) {
            return $item[1];
        }, static::$_definition);
    }

    /**
     * {@inheritDoc}
     *
     * @return string[]
     */
    public static function openAPIFormats(): array {
        return array_map(function ($item) {
            return $item[2];
        }, static::$_definition);
    }

    /**
     * {@inheritdoc}
     *
     * @return string[]
     */
    public static function getters(): array {
        return array_map(function ($item) {
            return $item[3];
        }, static::$_definition);
    }

    /**
     * {@inheritdoc}
     *
     * @return string[]
     */
    public static function setters(): array {
        return array_map(function ($item) {
            return $item[4];
        }, static::$_definition);
    }

    /**
     * {@inheritdoc}
     *
     * @return string
     */
    public function getModelName(): string {
        return static::$_name;
    }

    /**
     * {@inheritdoc}
     */
    public function valid(): bool {
        return 0 === count($this->listInvalidProperties());
    }

    /**
     * {@inheritdoc}
     *
     * @return $this
     */
    public function setAdditionalProperties(array $fields) {
        $fields = array_diff_key($fields, static::attributeMap());
        foreach ($this->_props as $prop) {
            unset($this->_data[$prop]);
        }

        $this->_data += $fields;
        $keys = array_keys($fields);
        $this->_props = array_combine($keys, $keys);

        return $this;
    }

    /**
     * {@inheritdoc}
     *
     * @return $this
     */
    public function setAdditionalProperty($property, $value) {
        if (isset(static::$_definition[$property])) {
            throw new InvalidArgumentException();
        }
        $this->_props[$property] = $property;
        $this->_data[$property] = $value;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function getAdditionalProperties(): array {
        $data = $this->_data;

        return array_map(function ($key) use ($data) {
            return $data[$key];
        }, $this->_props);
    }

    /**
     * {@inheritdoc}
     */
    public function offsetExists($offset): bool {
        return isset($this->_data[$offset]);
    }

    /**
     * {@inheritdoc}
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset) {
        return $this->_data[$offset] ?? null;
    }

    /**
     * {@inheritdoc}
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value): self {
        if (is_null($offset)) {
            throw new \RuntimeException(
                "Appending to a model does not make sense. Provide an explicit property instead"
            );
        } else {
            if (!isset(static::$_definition[$offset])) {
                $this->_props[$offset] = $offset;
            }
            $this->_data[$offset] = $value;
        }

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset): self {
        unset($this->_data[$offset]);

        return $this;
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode()
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize() {
        return Serializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     * @throws \JsonException
     */
    public function __toString() {
        return json_encode(Serializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT | JSON_THROW_ON_ERROR);
    }
}
